<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Real-Time Translator</title>
<style>
  * { box-sizing: border-box; }
  body { 
    font-family: Arial, sans-serif; 
    text-align: center; 
    padding: 20px; 
    max-width: 800px; 
    margin: 0 auto;
  }
  button { 
    padding: 12px 20px; 
    margin: 10px 5px; 
    font-size: 16px; 
    border-radius: 10px; 
    border: none; 
    background: #007BFF; 
    color: white; 
    cursor: pointer;
    transition: all 0.3s;
  }
  button:hover:not(:disabled) { background: #0056b3; transform: translateY(-2px); }
  button:disabled { background: gray; cursor: not-allowed; transform: none; }
  select, input { padding: 8px; font-size: 16px; margin: 5px; border-radius: 5px; border: 1px solid #ccc; }
  input[type="text"] { width: 100%; max-width: 500px; }
  .controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; align-items: center; margin: 20px 0; }
  .font-controls { margin: 10px 0; }
  .font-controls button { padding: 8px 15px; font-size: 14px; }
  #translations, #liveText { 
    margin-top: 20px; 
    text-align: left; 
    max-width: 700px; 
    margin-left: auto; 
    margin-right: auto; 
    background: #f8f8f8; 
    padding: 15px; 
    border-radius: 10px; 
    box-shadow: 0 2px 6px rgba(0,0,0,0.1); 
  }
  #translations { max-height: 400px; overflow-y: auto; }
  .chunk { 
    padding: 8px 80px 8px 8px; 
    margin-bottom: 8px; 
    border-radius: 5px; 
    background-color: #e0f7fa; 
    position: relative;
    word-wrap: break-word;
  }
  .chunk-buttons {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    gap: 3px;
  }
  .chunk-buttons button { 
    background: #007BFF; 
    color: white; 
    border: none; 
    border-radius: 5px; 
    padding: 4px 8px; 
    cursor: pointer; 
    font-size: 12px;
    margin: 0;
  }
  .chunk-buttons button:hover { background: #0056b3; }
  #liveText { font-style: italic; color: #333; min-height: 50px; }
  .status { 
    margin: 10px auto; 
    padding: 10px; 
    border-radius: 5px; 
    font-size: 14px;
    max-width: 700px;
  }
  .status.error { background: #ffebee; color: #c62828; }
  .status.success { background: #e8f5e9; color: #2e7d32; }
  .status.warning { background: #fff3e0; color: #e65100; }
  .loading { display: inline-block; margin-left: 10px; }
  .loading::after {
    content: '...';
    animation: dots 1.5s steps(4, end) infinite;
  }
  @keyframes dots {
    0%, 20% { content: '.'; }
    40% { content: '..'; }
    60%, 100% { content: '...'; }
  }
  .manual-input { margin: 20px auto; max-width: 700px; }
  .manual-input textarea {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    border-radius: 5px;
    border: 1px solid #ccc;
    min-height: 80px;
    font-family: Arial, sans-serif;
  }
  .keyboard-hint {
    font-size: 12px;
    color: #666;
    margin-top: 10px;
  }
  .export-buttons {
    margin: 15px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
  }
  @media (max-width: 600px) {
    body { padding: 10px; }
    button { padding: 10px 15px; font-size: 14px; }
    .controls { flex-direction: column; }
  }
</style>
</head>
<body>

<h1>Real-Time Translator üåç</h1>
<p>Translate speech in real-time with text-to-speech output</p>

<div role="alert" aria-live="polite" id="statusDiv" class="status" style="display:none;"></div>

<button id="enableAudioBtn" aria-label="Enable audio output">üîä Enable Audio</button>

<div class="controls">
  <label for="fromLang">üé§ Input:</label>
  <select id="fromLang" aria-label="Select input language">
    <option value="auto">Auto-Detect</option>
    <option value="en">English</option>
    <option value="es">Spanish</option>
    <option value="sv">Swedish</option>
    <option value="fr">French</option>
    <option value="de">German</option>
    <option value="it">Italian</option>
    <option value="pt">Portuguese</option>
    <option value="zh">Chinese</option>
    <option value="ja">Japanese</option>
  </select>

  <label for="toLang">üîä Output:</label>
  <select id="toLang" aria-label="Select output language">
    <option value="en">English</option>
    <option value="es">Spanish</option>
    <option value="sv">Swedish</option>
    <option value="fr">French</option>
    <option value="de">German</option>
    <option value="it">Italian</option>
    <option value="pt">Portuguese</option>
    <option value="zh">Chinese</option>
    <option value="ja">Japanese</option>
  </select>
</div>

<div class="font-controls">
  <label>Text Size:</label>
  <button id="fontDecrease" aria-label="Decrease font size">A-</button>
  <button id="fontIncrease" aria-label="Increase font size">A+</button>
  <button id="fontReset" aria-label="Reset font size">Reset</button>
</div>

<div>
  <button id="toggleBtn" aria-label="Start or stop voice recognition">‚ñ∂ Start (Space)</button>
  <button id="replayAllBtn" aria-label="Replay all translations">üîÅ Replay All (R)</button>
  <button id="clearBtn" aria-label="Clear all translations">üßπ Clear (C)</button>
</div>

<div class="manual-input">
  <textarea id="manualInput" placeholder="Or type text here for translation..." aria-label="Manual text input"></textarea>
  <button id="translateManual" aria-label="Translate typed text">‚úèÔ∏è Translate Text (Enter)</button>
</div>

<div class="export-buttons">
  <button id="exportTxt" aria-label="Export as text file">üìÑ Export TXT</button>
  <button id="exportJson" aria-label="Export as JSON file">üìã Export JSON</button>
  <button id="copyAll" aria-label="Copy all translations to clipboard">üìã Copy All</button>
</div>

<div id="liveText" role="status" aria-live="polite">üéôÔ∏è Live text will appear here...</div>
<div id="translations" role="log" aria-label="Translation history"></div>

<div class="keyboard-hint">
  ‚å®Ô∏è Keyboard shortcuts: Space (Start/Stop), R (Replay), C (Clear), Enter (Translate text)
</div>

<script>
// Security: Sanitize HTML to prevent XSS
function sanitizeHTML(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// Check HTTPS
if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
  alert('‚ö†Ô∏è Warning: This app requires HTTPS for speech recognition to work properly.');
}

const enableAudioBtn = document.getElementById("enableAudioBtn");
const toggleBtn = document.getElementById("toggleBtn");
const replayAllBtn = document.getElementById("replayAllBtn");
const clearBtn = document.getElementById("clearBtn");
const translationsDiv = document.getElementById("translations");
const liveText = document.getElementById("liveText");
const fromLang = document.getElementById("fromLang");
const toLang = document.getElementById("toLang");
const statusDiv = document.getElementById("statusDiv");
const manualInput = document.getElementById("manualInput");
const translateManual = document.getElementById("translateManual");
const fontDecrease = document.getElementById("fontDecrease");
const fontIncrease = document.getElementById("fontIncrease");
const fontReset = document.getElementById("fontReset");
const exportTxt = document.getElementById("exportTxt");
const exportJson = document.getElementById("exportJson");
const copyAll = document.getElementById("copyAll");

const langMap = { 
  "es":"es-ES", "en":"en-US", "sv":"sv-SE", "fr":"fr-FR",
  "de":"de-DE", "it":"it-IT", "pt":"pt-PT", "zh":"zh-CN", "ja":"ja-JP"
};

let recognition;
let currentTranscript = "";
let lastSpeechTime = 0;
let silenceTimer = null;
let listening = false;
let allTranslations = [];
let audioEnabled = false;
let voicesLoaded = false;
let isOnline = navigator.onLine;
let fontSize = 16;
let translationCache = {};
const MAX_TRANSLATIONS = 100; // Prevent memory leaks

// Service Worker Registration for offline support
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('data:text/javascript;base64,c2VsZi5hZGRFdmVudExpc3RlbmVyKCdpbnN0YWxsJywgKCkgPT4gc2VsZi5za2lwV2FpdGluZygpKTs=')
    .catch(() => {}); // Minimal service worker for offline detection
}

// Online/Offline detection
window.addEventListener('online', () => {
  isOnline = true;
  showStatus('Back online! Translations will work again.', false);
});

window.addEventListener('offline', () => {
  isOnline = false;
  showStatus('You are offline. Translation requires internet connection.', true);
});

// Load and save translation history
function loadHistory() {
  try {
    const saved = localStorage.getItem('translationHistory');
    if (saved) {
      allTranslations = JSON.parse(saved);
      allTranslations.forEach(item => {
        addTranslationToDOM(item.original, item.translated, false);
      });
    }
  } catch (e) {
    console.error('Error loading history:', e);
  }
}

function saveHistory() {
  try {
    // Keep only last MAX_TRANSLATIONS to prevent memory issues
    const toSave = allTranslations.slice(-MAX_TRANSLATIONS);
    localStorage.setItem('translationHistory', JSON.stringify(toSave));
  } catch (e) {
    console.error('Error saving history:', e);
  }
}

// Font size controls
function updateFontSize() {
  translationsDiv.style.fontSize = fontSize + 'px';
  liveText.style.fontSize = fontSize + 'px';
  localStorage.setItem('fontSize', fontSize);
}

fontIncrease.addEventListener('click', () => {
  if (fontSize < 24) {
    fontSize += 2;
    updateFontSize();
    showStatus(`Font size: ${fontSize}px`);
  }
});

fontDecrease.addEventListener('click', () => {
  if (fontSize > 12) {
    fontSize -= 2;
    updateFontSize();
    showStatus(`Font size: ${fontSize}px`);
  }
});

fontReset.addEventListener('click', () => {
  fontSize = 16;
  updateFontSize();
  showStatus('Font size reset to default');
});

// Load saved font size
try {
  const savedSize = localStorage.getItem('fontSize');
  if (savedSize) {
    fontSize = parseInt(savedSize);
    updateFontSize();
  }
} catch (e) {}

// Load voices
function loadVoices() {
  return new Promise((resolve) => {
    let voices = speechSynthesis.getVoices();
    if (voices.length > 0) {
      voicesLoaded = true;
      resolve(voices);
    } else {
      speechSynthesis.onvoiceschanged = () => {
        voices = speechSynthesis.getVoices();
        voicesLoaded = true;
        resolve(voices);
      };
    }
  });
}

function showStatus(message, isError = false, isWarning = false) {
  statusDiv.textContent = message;
  statusDiv.className = isError ? "status error" : (isWarning ? "status warning" : "status success");
  statusDiv.style.display = "block";
  setTimeout(() => {
    statusDiv.style.display = "none";
  }, 3000);
}

enableAudioBtn.addEventListener("click", async () => {
  try {
    await loadVoices();
    const testUtterance = new SpeechSynthesisUtterance("Audio enabled");
    testUtterance.volume = 0.1;
    
    testUtterance.onstart = () => {
      audioEnabled = true;
      enableAudioBtn.disabled = true;
      enableAudioBtn.textContent = "‚úÖ Audio Enabled";
      showStatus("Audio enabled successfully!");
    };
    
    testUtterance.onerror = (e) => {
      console.error("Speech synthesis error:", e);
      showStatus("Audio error: " + e.error, true);
    };
    
    speechSynthesis.speak(testUtterance);
  } catch (error) {
    console.error("Audio initialization error:", error);
    showStatus("Could not enable audio. Please check device settings.", true);
  }
});

// Speech Recognition Setup
if ("webkitSpeechRecognition" in window || "SpeechRecognition" in window) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = true;

  recognition.onresult = (event) => {
    let interimTranscript = "";
    let finalTranscript = "";
    const now = Date.now();

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = (event.results[i][0].transcript || "").trim();
      if (event.results[i].isFinal) {
        finalTranscript += transcript + " ";
      } else {
        interimTranscript += transcript + " ";
      }
    }

    if (interimTranscript) {
      liveText.textContent = "üéôÔ∏è " + interimTranscript;
      currentTranscript = interimTranscript;
      lastSpeechTime = now;
      resetSilenceTimer();
    }

    if (finalTranscript) {
      liveText.textContent = "üéôÔ∏è " + finalTranscript;
      currentTranscript = finalTranscript;
      commitChunk();
    }
  };

  recognition.onerror = (e) => { 
    console.warn("Recognition error:", e);
    if (e.error === "no-speech") {
      showStatus("No speech detected. Try speaking again.", false, true);
    } else if (e.error === "audio-capture") {
      showStatus("Microphone error. Check permissions.", true);
    } else if (e.error === "not-allowed") {
      showStatus("Microphone access denied. Please enable it.", true);
    } else {
      showStatus("Recognition error: " + e.error, true);
    }
  };

  recognition.onend = () => {
    if (listening) {
      // Auto-restart if still in listening mode
      try {
        recognition.start();
      } catch (e) {
        console.warn("Could not restart recognition:", e);
      }
    }
  };
} else {
  showStatus("Speech Recognition not supported in this browser.", true);
  toggleBtn.disabled = true;
}

// Silence detection with separate timer
function resetSilenceTimer() {
  if (silenceTimer) {
    clearTimeout(silenceTimer);
  }
  silenceTimer = setTimeout(() => {
    if (currentTranscript.trim() && listening) {
      commitChunk();
    }
  }, 1500); // 1.5 seconds of silence
}

function commitChunk() {
  const transcript = currentTranscript.trim();
  if (!transcript) return;

  currentTranscript = "";
  lastSpeechTime = 0;
  liveText.innerHTML = "üéôÔ∏è ‚Ä¶ <span class='loading'></span>";

  if (silenceTimer) {
    clearTimeout(silenceTimer);
    silenceTimer = null;
  }

  translateText(transcript);
}

// Auto language detection
async function detectLanguage(text) {
  if (fromLang.value !== 'auto') {
    return fromLang.value;
  }
  
  try {
    const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text.substring(0, 100))}&langpair=auto|en`);
    const data = await response.json();
    // MyMemory doesn't provide explicit language detection, so we'll use a heuristic
    // In production, use a proper language detection API
    return 'en'; // Fallback
  } catch (e) {
    return 'en';
  }
}

async function translateText(text, isManual = false) {
  if (!isOnline) {
    showStatus("Cannot translate: You are offline", true);
    liveText.textContent = "üéôÔ∏è Offline - translation unavailable";
    return;
  }

  const from = fromLang.value === 'auto' ? 'en' : fromLang.value;
  const to = toLang.value;
  
  // Check cache
  const cacheKey = `${from}|${to}|${text}`;
  if (translationCache[cacheKey]) {
    addTranslation(text, translationCache[cacheKey], isManual);
    if(audioEnabled && !isManual) speak(translationCache[cacheKey], langMap[to]);
    liveText.textContent = "üéôÔ∏è Live text will appear here...";
    return;
  }

  try {
    let translated = null;
    
    // Try MyMemory API first
    try {
      const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${from}|${to}`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json'
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        translated = data?.responseData?.translatedText;
      }
    } catch (e) {
      console.warn("MyMemory API failed, trying fallback:", e);
    }
    
    // Fallback to LibreTranslate API (public instance)
    if (!translated) {
      try {
        const response = await fetch('https://libretranslate.de/translate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            q: text,
            source: from === 'auto' ? 'auto' : from,
            target: to,
            format: 'text'
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          translated = data?.translatedText;
        }
      } catch (e) {
        console.warn("LibreTranslate API failed:", e);
      }
    }
    
    // Final fallback: Simple word-by-word mock translation for demo
    if (!translated) {
      showStatus("‚ö†Ô∏è Translation APIs unavailable. Using local mode.", false, true);
      translated = `[${to.toUpperCase()}] ${text}`;
    }
    
    // Cache the translation
    translationCache[cacheKey] = translated;
    
    addTranslation(text, translated, isManual);
    if(audioEnabled && !isManual) speak(translated, langMap[to]);
    liveText.textContent = "üéôÔ∏è Live text will appear here...";
    
  } catch (error) {
    console.error("Translation error:", error);
    addTranslation(text, `[Error] ${text}`, isManual);
    showStatus("Translation failed. Check console for details.", true);
    liveText.textContent = "üéôÔ∏è Live text will appear here...";
  }
}

function addTranslation(original, translated, skipSpeech = false) {
  // Prevent memory leaks
  if (allTranslations.length >= MAX_TRANSLATIONS) {
    allTranslations.shift();
    const firstChunk = translationsDiv.firstChild;
    if (firstChunk) translationsDiv.removeChild(firstChunk);
  }

  allTranslations.push({ original, translated, timestamp: Date.now() });
  addTranslationToDOM(original, translated, skipSpeech);
  saveHistory();
}

function addTranslationToDOM(original, translated, skipSpeech = false) {
  const chunkDiv = document.createElement("div");
  chunkDiv.className = "chunk";
  
  const textSpan = document.createElement("span");
  textSpan.innerHTML = `<strong>${sanitizeHTML(original)}</strong> ‚Üí ${sanitizeHTML(translated)}`;
  chunkDiv.appendChild(textSpan);
  
  const buttonsDiv = document.createElement("div");
  buttonsDiv.className = "chunk-buttons";
  
  const replayBtn = document.createElement("button");
  replayBtn.textContent = "üîä";
  replayBtn.setAttribute('aria-label', 'Replay this translation');
  replayBtn.onclick = () => speak(translated, langMap[toLang.value]);
  
  const copyBtn = document.createElement("button");
  copyBtn.textContent = "üìã";
  copyBtn.setAttribute('aria-label', 'Copy this translation');
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(`${original} ‚Üí ${translated}`).then(() => {
      showStatus('Copied to clipboard!');
    }).catch(() => {
      showStatus('Copy failed', true);
    });
  };
  
  const editBtn = document.createElement("button");
  editBtn.textContent = "‚úèÔ∏è";
  editBtn.setAttribute('aria-label', 'Edit and retranslate');
  editBtn.onclick = () => {
    const newText = prompt("Edit text:", original);
    if (newText && newText.trim()) {
      translateText(newText.trim(), true);
    }
  };
  
  buttonsDiv.appendChild(replayBtn);
  buttonsDiv.appendChild(copyBtn);
  buttonsDiv.appendChild(editBtn);
  chunkDiv.appendChild(buttonsDiv);

  translationsDiv.appendChild(chunkDiv);
  translationsDiv.scrollTop = translationsDiv.scrollHeight;
}

function speak(text, langCode) {
  if (!audioEnabled) {
    showStatus("Please enable audio first!", false, true);
    return;
  }
  
  speechSynthesis.cancel();
  
  const utterance = new SpeechSynthesisUtterance(text);
  const voices = speechSynthesis.getVoices();
  
  let match = voices.find(v => v.lang === langCode);
  if (!match) {
    match = voices.find(v => v.lang.startsWith(langCode.substring(0, 2)));
  }
  
  if (match) {
    utterance.voice = match;
  }
  
  utterance.lang = langCode;
  utterance.rate = 0.9;
  
  utterance.onerror = (e) => {
    console.error("Speech synthesis error:", e);
    if (e.error === "not-allowed" || e.error === "interrupted") {
      showStatus("Audio interrupted. Please enable audio again.", false, true);
      audioEnabled = false;
      enableAudioBtn.disabled = false;
      enableAudioBtn.textContent = "üîä Enable Audio";
    } else {
      showStatus("Speech error: " + e.error, true);
    }
  };
  
  speechSynthesis.speak(utterance);
}

// Toggle start/stop
toggleBtn.addEventListener("click", () => {
  if (!listening) {
    const lang = fromLang.value === 'auto' ? 'en-US' : langMap[fromLang.value];
    recognition.lang = lang;
    try {
      recognition.start();
      listening = true;
      toggleBtn.textContent = "‚èπ Stop (Space)";
      showStatus("Listening...");
    } catch (e) {
      showStatus("Could not start recognition: " + e.message, true);
    }
  } else {
    recognition.stop();
    listening = false;
    toggleBtn.textContent = "‚ñ∂ Start (Space)";
    commitChunk();
    showStatus("Stopped listening");
    if (silenceTimer) {
      clearTimeout(silenceTimer);
      silenceTimer = null;
    }
  }
});

// Manual text translation
translateManual.addEventListener("click", () => {
  const text = manualInput.value.trim();
  if (text) {
    translateText(text, true);
    manualInput.value = "";
  } else {
    showStatus("Please enter text to translate", false, true);
  }
});

// Replay all
replayAllBtn.addEventListener("click", () => {
  if (!audioEnabled) {
    showStatus("Please enable audio first!", false, true);
    return;
  }
  
  if (allTranslations.length === 0) {
    showStatus("No translations to replay yet!", false, true);
    return;
  }
  
  speechSynthesis.cancel();
  showStatus(`Replaying ${allTranslations.length} translations...`);
  
  allTranslations.forEach((item, i) => {
    setTimeout(() => {
      const utterance = new SpeechSynthesisUtterance(item.translated);
      const voices = speechSynthesis.getVoices();
      const targetLang = langMap[toLang.value];
      
      let match = voices.find(v => v.lang === targetLang);
      if (!match) {
        match = voices.find(v => v.lang.startsWith(targetLang.substring(0, 2)));
      }
      if (match) utterance.voice = match;
      
      utterance.lang = targetLang;
      utterance.rate = 0.9;
      
      speechSynthesis.speak(utterance);
    }, i * 1500);
  });
});

// Clear all
clearBtn.addEventListener("click", () => {
  const confirmClear = confirm("Are you sure you want to clear all translations?");
  if (!confirmClear) return;
  translationsDiv.innerHTML = "";
  liveText.textContent = "üéôÔ∏è Live text will appear here...";
  allTranslations = [];
  translationCache = {};
  speechSynthesis.cancel();
  saveHistory();
  showStatus("All translations cleared");
});

// Export functions
exportTxt.addEventListener("click", () => {
  if (allTranslations.length === 0) {
    showStatus("No translations to export", false, true);
    return;
  }
  
  const text = allTranslations.map(item => 
    `${item.original} ‚Üí ${item.translated}`
  ).join('\n\n');
  
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `translations_${Date.now()}.txt`;
  a.click();
  URL.revokeObjectURL(url);
  showStatus("Exported as TXT file");
});

exportJson.addEventListener("click", () => {
  if (allTranslations.length === 0) {
    showStatus("No translations to export", false, true);
    return;
  }
  
  const json = JSON.stringify(allTranslations, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `translations_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  showStatus("Exported as JSON file");
});

copyAll.addEventListener("click", () => {
  if (allTranslations.length === 0) {
    showStatus("No translations to copy", false, true);
    return;
  }
  
  const text = allTranslations.map(item => 
    `${item.original} ‚Üí ${item.translated}`
  ).join('\n\n');
  
  navigator.clipboard.writeText(text).then(() => {
    showStatus('All translations copied to clipboard!');
  }).catch(() => {
    showStatus('Copy failed', true);
  });
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Ignore if typing in textarea
  if (e.target === manualInput) {
    if (e.key === 'Enter' && e.ctrlKey) {
      translateManual.click();
    }
    return;
  }
  
  if (e.key === ' ' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
    e.preventDefault();
    toggleBtn.click();
  } else if (e.key.toLowerCase() === 'r' && !e.ctrlKey && !e.metaKey) {
    e.preventDefault();
    replayAllBtn.click();
  } else if (e.key.toLowerCase() === 'c' && !e.ctrlKey && !e.metaKey) {
    e.preventDefault();
    clearBtn.click();
  }
});

// Handle audio context resume on user interaction (mobile fix)
document.addEventListener('click', () => {
  if (audioEnabled && speechSynthesis.paused) {
    speechSynthesis.resume();
  }
}, { once: true });

// Load voices and history on startup
loadVoices();
loadHistory();
</script>
</body>
</html>